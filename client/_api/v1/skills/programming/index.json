{"section":"Programming","groups":[{"group":"Algorithms","path":"programming/algorithms","levels":[{"level":0,"description":"Basic sorting, searching and data structure traversal and retrieval algorithms"},{"level":1,"description":"Big O notation. Tree, Graph, Pathfinding, simple greedy and divide and conquer algorithms. More nuanced algorithms (pathfinding, tree-traversal)"},{"level":2,"description":"Able to recognize and code dynamic programming solutions, good knowledge of graph algorithms, good knowledge of numerical computation algorithms, able to identify NP problems etc."},{"level":3,"description":"Concrete mathematical evaluation of tradeoffs between algorithms and data structures."}]},{"group":"Data Structures","path":"programming/data-structures","levels":[{"level":0,"description":"Basic ADTs (array vs hash vs stack vs queue), "},{"level":1,"description":"More nuanced ADTs (directed vs nondirected graphs, trees, etc.). Able to explain and use Arrays, Stacks, Queus, Dictionaries etc in practical programming tasks"},{"level":2,"description":"Knows space and time tradeoffs of the basic data structures, Arrays vs LinkedLists, Able to explain how hashtables can be implemented and can handle collisions, Priority queues and ways to implement them etc."},{"level":3,"description":"Basic mathematical proofs of data structure performance. Knowledge of advanced data structures like B-trees, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries etc."}]},{"group":"Functional Programming","path":"programming/functional-programming","levels":[{"level":0,"description":"Immutability, .map and .reduce"},{"level":1,"description":"Composition with higher-order function decorators, currying"},{"level":2,"description":"Generators/co-routines, memoization, lazy evaluation"},{"level":3,"description":"Understands deeply tradeoff/philosophy of functional programming"}]},{"group":"Object Oriented Programming","path":"programming/object-oriented-programming","levels":[{"level":0,"description":"Objects. Scope. Public/private methods and properties"},{"level":1,"description":"Inheritence. Class composition. SOLID. "},{"level":2,"description":"Factory patterns, and other OO design patterns"},{"level":3,"description":"Advanced OO"}]},{"group":"Problem Decomposition","path":"programming/problem-decomposition","levels":[{"level":0,"description":""},{"level":1,"description":""},{"level":2,"description":"Able to come up with reusable functions/objects that solve the overall problem. Basic code reuse (no copy/paste)"},{"level":3,"description":"Use of appropriate data structures and algorithms and comes up with generic/object-oriented code that encapsulate aspects of the problem that are subject to change."}]},{"group":"Regular Expressions","path":"programming/regular-expressions","levels":[{"level":0,"description":"Basic Regular Expressions"},{"level":1,"description":"Intermediate Regular Expressions"},{"level":2,"description":"Advanced Regular Expressions"},{"level":3,"description":"Ninja-level Regular Expressions"}]},{"group":"Requirements","path":"programming/requirements","levels":[{"level":0,"description":"Takes the given requirements and codes to spec"},{"level":1,"description":"Clarifies spec. through questions regarding missed cases and ambigious requirements"},{"level":2,"description":"Understand complete picture and come up with entire areas that need to be speced"},{"level":3,"description":"Able to suggest better alternatives and flows to given requirements based on experience"}]},{"group":"Systems Decomposition","path":"programming/systems-decomposition","levels":[{"level":0,"description":"Able to think/build within the level of a single file/class"},{"level":1,"description":"Able to break up problem space and design solution as long as it is within the same platform/technology"},{"level":2,"description":"Able to design and work in systems that span multiple technologies/platforms."},{"level":3,"description":"Able to visualize and design complex systems with multiple product lines and integrations with external systems. Also should be able to design operations support systems like monitoring, reporting, fail overs etc."}]},{"group":"Systems Programming","path":"programming/systems-programming","levels":[{"level":0,"description":""},{"level":1,"description":"Basic understanding of compilers, linker and interpreters. Understands what assembly code is and how things work at the hardware level. Some knowledge of virtual memory and paging."},{"level":2,"description":"Understands kernel mode vs. user mode, multi-threading, synchronization primitives and how they're implemented, able to read assembly code. Understands how networks work, understanding of network protocols and socket level programming."},{"level":3,"description":"Understands the entire programming stack, hardware (CPU + Memory + Cache + Interrupts + microcode), binary code, assembly, static and dynamic linking, compilation, interpretation, JIT compilation, garbage collection, heap, stack, memory addressing..."}]},{"group":"Testing","path":"programming/testing","levels":[{"level":0,"description":"Unit testing, enzyme, sinon, tape/mocha"},{"level":1,"description":"Separates unit and integration tests, checks code coverage, understands TDD-guided design"},{"level":2,"description":"Always writes tests first, Functional testing (selenium), Understands benefits of TDD"},{"level":3,"description":"Uses static analysis tools like cyclomatic complexity and afferent/efferent coupling checks, patterns (GoF and Fowler), nonfunctional testing (capacity testing)"}]}]}