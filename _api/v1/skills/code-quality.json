{"section":"Code Quality","groups":[{"group":"Code Construction","levels":[{"level":0,"description":"Basics (Code Complete): concise commenting, intermediate variables, no long functions, well-factored self-documenting code, eslint is setup"},{"level":1,"description":"SOLID principals, knows popular eslint configs, and what eslint rules to break"},{"level":2,"description":"Has worked on larger code base with multiple developers, to see/participate in larger code base organization across multiple team"},{"level":3,"description":"Has worked on a project over a long period with multiple developers, to see common pitfalls and what is actually practical and maintainable"}]},{"group":"Code Organization","levels":[{"level":0,"description":""},{"level":1,"description":"Methods are grouped logically or by accessibility. Basic separation of code into logical folders."},{"level":2,"description":"Code is grouped into regions and well commented with references to other source files. Each physical file has a unique purpose, for e.g. one class definition, one feature implementation etc. "},{"level":3,"description":"Code organization at a physical level closely matches design and looking at file names and folder distribution provides insights into design. Physical layout of source tree matches logical hierarchy and organization. The directory names and organization provide insights into the design of the system."}]},{"group":"Code Readability","levels":[{"level":0,"description":""},{"level":1,"description":"Good names for files, variables classes, methods etc. Attention paid to commit messages. Consistent white space usage. "},{"level":2,"description":"No long functions, comments explaining unusual code, bug fixes, code assumptions functions, comments explaining unusual code, bug fixes, code assumptions. Clean, precise commit messages. "},{"level":3,"description":"Code assumptions are verified using asserts, code flows naturally - no deep nesting of conditionals or methods. Commit messages tell a coherent story. "}]},{"group":"Defensive Coding and Error Handling","levels":[{"level":0,"description":"Checks all arguments and asserts critical assumptions in code. Basic error handling around code that can throw exceptions/generate errors"},{"level":1,"description":"Makes sure to check return values and check for exceptions around code that can fail. Ensures that error/exceptions leave program in good state, resources, connections and memory is all cleaned up properly."},{"level":2,"description":"Codes to detect possible exception before, maintain consistent exception handling strategy in all layers of code, come up with guidelines on exception handling for entire system."},{"level":3,"description":"Has own library to help with defensive coding, writes unit tests that simulate faults"}]}]}